# Jack 的 AI 助手實踐筆記：從 Mini-Claw 探索生產級架構

嘿！我是 Jack。這份文件紀錄了我如何參考生產級的 AI 助手專案 **OpenClaw**，親手打造出這個精簡版的 `jack-mini-claw`。我的目標是弄清楚一個具備「大腦」與「手腳」的 AI 助手到底是怎麼運作的。

---

## �️ 我所觀察到的 AI 助手五大組件

在研究 OpenClaw 時，我發現一個完整的 AI 平台其實是由這五個支柱撐起來的：

1.  **網關 (Gateway)**：這是大腦的總管，負責決定訊息要分給誰、誰跟誰在說話。
2.  **思考引擎 (Agent Runtime)**：AI 真正的思考核心，在這裡它會決定下一步要「做什麼」。
3.  **通路適配器 (Connectors)**：負責「收發訊息」的傳聲筒（例如幫我對接到 Telegram 或 WhatsApp）。
4.  **工具系統 (Tooling/MCP)**：這是 AI 的手腳，讓它能執行我給它的指令或去網路上抓資料。
5.  **安全沙盒 (Sandbox)**：最重要的一環，確保 AI 在執行指令時不會把我的電腦弄壞。

---

## 🛠️ 我的專案結構：`jack-mini-claw`

為了學習，我把這些複雜的概念拆解成幾個簡單的檔案。我的專案是這樣運作的：

*   **`bot.ts` (通路)**：這是我對外通訊的窗口。我使用了 `grammY` 套件來跟 Telegram API 連線。
*   **`ai.ts` (思考)**：這裡是我跟 Google Gemini 模型溝通的地方。我在這裡定義了 AI 能用的「工具清單」。
*   **`executor.ts` (手腳)**：它負責在我的電腦上執行 Shell 指令（如 `ls`, `cat`）。
*   **`index.ts` (網關)**：這是我的主程式。它把上面三個部分黏在一起，協調整個訊息流程。
*   **`memory.ts` (記憶)**：我用它來幫 AI 找回「忘掉的事情」，它會存下每個人的對話紀錄。

---

## 🔄 這是如何運作的？(工作流程)

當我在 Telegram 上發送：「幫我看看目錄下有哪些檔案」時：

1.  **收件**：`bot.ts` 收到訊息，傳給 `index.ts`。
2.  **思考**：`index.ts` 問 `ai.ts`：「用戶想幹嘛？」。Gemini 發現我需要執行指令，回傳：「請執行 `ls`」。
3.  **執行**：`index.ts` 叫 `executor.ts` 去跑 `ls` 指令。
4.  **回報**：執行結果傳回給 `ai.ts` 進行總結，最後由 `bot.ts` 把答案發回給我。

---

## 🧠 我的進階實作原理

### 1. 它是怎麼「記得」我是誰的？ (Memory)
我在 `memory.ts` 裡用了一個簡單的 Map 結構。只要 Telegram 給我 `chatId`，我就能幫每個用戶開一個獨立的「筆記本」。
在呼叫 Gemini 時，我會把這本筆記本（對話紀錄）一起塞進 `startChat({ history })`。但筆記本不能無限長，所以我設定只保留最近 10 輪對話，既省錢又精確。

### 2. 我如何防止 AI 把我的電腦刪光？ (Security)
這是我覺得最驚險的部分。因為 AI 可能會產出危險指令，我在 `executor.ts` 裡親自寫了一個「黑名單 (Blacklist)」。
只要指令裡包含 `rm` (刪除)、`sudo` (最高權限) 或 `>` (重寫檔案) 等關鍵字，我的程式就會直接攔截，拒絕執行。雖然這不像 OpenClaw 使用 Docker 沙盒那麼專業，但對我的個人實驗來說非常管用。

---

## 📊 我的 Mini-Claw 與 OpenClaw 的對應關係

| 我的組件 | 對應 OpenClaw 的位置 | 功能說明 |
| :--- | :--- | :--- |
| `bot.ts` | `src/connectors/` | 處理外部通訊協定 |
| `ai.ts` | `src/agent/` | 核心推理邏輯 |
| `index.ts` | `src/gateway/` | 訊息分發處理中心 |
| `executor.ts` | `src/sandbox/` | 指令執行的環境防護 |

---

這就是我的開發筆記！這段過程讓我學到，要開發一個 AI 助手，除了要會串接模型 API，更重要的是如何整合**通路**、**記憶**與**安全控制**。這是我通往全能 AI 工程師的第一步！

*Jack 整理於 2026-02-06*
